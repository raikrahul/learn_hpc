---
layout: default
title: "Lesson 1"
date: 2024-03-04
---

## Lesson 1

Lesson 1 content goes here.
#include <stdio.h> // stdio.h (1) - BOF via printf, HPC I/O bottleneck.
#include <omp.h> // omp.h (2) - OpenMP Races, Thread Safety, Collapse?

/*
  This program demonstrates OpenMP sections.
  Sections divide code block into parallel parts.
  Each section can run by different threads.

  Inputs: None

  Outputs: Prints messages from parallel sections.
*/

void task_a() {
  printf("Task A is being executed by thread %d\n", omp_get_thread_num());
  // task_a (2) - printf - I/O in parallel task - serialization?
  //         Thread Safety? If SHARED resources outside printf! Review it!
  // L2-Algo: printf workload trivial. Perf bottleneck if tasks complex, I/O.
  // L3-System: Parallel printf syscalls. I/O lock contention likely.
  // L4-Edge: Task_a assumed thread-safe NOW, but what if complex later?
  // CTO Rec: Tasks (a,b,c) NEED Thread Safety audit - if access SHARED data.
}

void task_b() {
  printf("Task B is being executed by thread %d\n", omp_get_thread_num());
  // task_b (3) - printf in parallel task, Thread Safety like task_a?
  // CTO Rec: Parallel sections for DECOMPOSED compute tasks, NOT I/O.
  //         Re-design logging if I/O is parallel bottleneck in sections.
  // Similar to task_a, but for Task B.
}

void task_c() {
  printf("Task C is being executed by thread %d\n", omp_get_thread_num());
  // task_c (4) - printf. Thread Safety like task_a & b? Audit!
  // CTO Rec: Document data sharing & sync in EACH section, Thread Safety MUST be in design.
  // Similar to task_a and task_b, but for Task C.
}

int main() {
  printf("Starting parallel sections example.\n");
  // Initial printf (5) - Serial start msg. No HPC bugs at serial start.

  #pragma omp parallel sections // Parallel sections begin (6) - Thread Safety risk if tasks share data bad.
  // L1-API: OpenMP parallel sections. Concurrent sections IF threads, no dep.
  // L2-Algo: Sections BEST for INDEPENDENT work units. SHARED MUTABLE data?
  //         -> Race Condition LIKELY if no sync!
  // L3-HPC: OpenMP threads non-deterministic section exec order = Race hell!
  // L4-Edge: INSUFFICIENT THREADS for all sections -> Thread Reuse non-det!
  // CTO Rec: Enforce task independence in sections OR explicit sync inside.
  //         DOCUMENT data sharing & sync in parallel sections region design.

  // OpenMP directive for parallel sections region. Code in {} sections.
  // OpenMP tries to run sections in parallel with available threads.
  {
    #pragma omp section // Section 1 (7) - task_a - Thread-safe ASSUMPTION so far. What if it gets complex??
    // Section pragma in 'parallel sections'. Task_a() code in this section.
    {
      task_a(); // Execute task_a (8) - Race in task_a if shared data & unsafe access.
    } // Section 1 end

    #pragma omp section // Section 2 (9) - task_b - Thread Safety audit task_b NOW too!
    {
      task_b(); // Execute task_b (10) - Race Condition in task_b. Review task body code!
    } // Section 2 end

    #pragma omp section // Section 3 (11) - task_c - Thread Safety in task_c body? Check ALL!
    {
      task_c(); // Execute task_c (12) - Race Condition in task_c - all tasks audit req.
    } // Section 3 end
  } // Parallel sections region end (13) - Implicit Barrier - Load Imbalance issue point.
  // L3-HPC: Implicit Barrier at #pragma omp sections end. Threads sync here.
  // L3-HPC: Barrier -> Load Imbalance in tasks = idle wait time at barrier.
  // L4-Edge: Non-uniform task times -> barrier wait dominates parallel runtime.
  // CTO Rec: Analyze task time variance. Load balance techniques if needed.
  //         Dynamic sched in sections? Task-based parallelism may be better.

  printf("Finished parallel sections example.\n");
  // Final printf (14) - Serial end message. No HPC bug issues here.
  return 0; // Exit main (15) - Clean exit. No HPC bugs for program exit.
}
