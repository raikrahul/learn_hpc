---
layout: default
title: "Lesson 8"
date: 2024-03-11
---

## Lesson 8
Step 1:
```
omp_get_thread_num
omp_get_num_threads
omp_set_num_threads
omp_parallel
omp_single
omp_barrier
copyprivate
reduction
```

Step 2:
```c
// filename: parallel_array_processing.c
// Compilation: gcc -fopenmp parallel_array_processing.c -o parallel_array_processing

#include <stdio.h>
#include <omp.h>

int main() {
    int data[8][16]; // Example 2D array
    int sums[8] = {0};
    int max_val;


    // Initialize the array with some sample data.
    // User should implement meaningful initialization.
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 16; j++) {
            data[i][j] = (i + 1) * (j + 1);
        }
    }

    omp_set_num_threads(8); // Set the desired number of threads.

#pragma omp parallel shared(data, sums, max_val)
    {
        int thread_id = omp_get_thread_num();
        int num_threads = omp_get_num_threads();
        int local_max = 0;

        // Each thread processes a different row of the array.
        int start_row = thread_id * (8 / num_threads);
        int end_row = (thread_id + 1) * (8 / num_threads);

        if (thread_id == num_threads -1) end_row = 8; // Adjust for remainders

        for (int i = start_row; i < end_row; i++) {
            for (int j = 0; j < 16; j++) {
                sums[i] += data[i][j];
                if (data[i][j] > local_max) {
                    local_max = data[i][j];
                }
            }
        }

#pragma omp critical
        {
            if (local_max > max_val) {
                max_val = local_max;
            }
        }

#pragma omp barrier

#pragma omp single
        {
            printf("Maximum value found: %d\n", max_val);
            for (int i = 0; i < 8; i++) {
                printf("Sum of row %d: %d\n", i, sums[i]);
            }
        }
    }

    return 0;
}
```

